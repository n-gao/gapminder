<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Channeling Hans</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="main.css" />
    <script src="d3/d3.v4.js"></script>
</head>

<body>
    <div id="visualizations">

    </div>
    <script>
        // Define margins
        const plot = {
            outer_width: 750,
            outer_height: 500,
            margin: {
                top: 10,
                right: 10,
                bottom: 50,
                left: 50
            },
            legend_offset: 20,
            width: 0,
            height: 0,
            canvas: null
        };

        const pillarPlot = {
            outer_height: plot.outer_height,
            outer_width: 500,
            margin: {
                top: 10,
                right: 25,
                bottom: 50,
                left: 150
            },
            width: 0,
            height: 0,
            canvas: null
        }

        const control = {
            outer_width: plot.outer_width,
            outer_height: 100,
            margin: {
                top: 25,
                right: 25,
                bottom: 10,
                left: 25
            },
            lineOffset: 50,
            width: 0,
            height: 0,
            canvas: null
        }

        const pillarNames = [
            'Insitutions',
            'Infrastructure',
            'Macroeconimic environment',
            'Health and primary education',
            'Higher education and training',
            'Goods market efficiency',
            'Labor market efficiency',
            'Financial market development',
            'Technological readiness',
            'Market size',
            'Business sophistication',
            'Innovation'
        ]

        function generateSvgCanvas(dims, parent) {
            dims.width = dims.outer_width - dims.margin.left - dims.margin.right;
            dims.height = dims.outer_height - dims.margin.top - dims.margin.bottom;

            dims.svg = d3.select(parent)
                .append("svg")
                .attr("width", dims.outer_width)
                .attr("height", dims.outer_height);
            dims.canvas = dims.svg.append("g")
                .attr("transform", "translate(" + dims.margin.left + "," + dims.margin.top + ")");
        }

        generateSvgCanvas(plot, "#visualizations");
        generateSvgCanvas(pillarPlot, "#visualizations");
        generateSvgCanvas(control, "body");

        d3.select("#visualizations").style("width", plot.outer_width + pillarPlot.outer_width + 'px');


        // Set up the scale to be used on the x axis
        const xScale = d3.scaleLog()
            .range([0, plot.width]);
        // Set up the scale to be used on the y axis
        const yScale = d3.scaleLinear()
            .range([plot.height, 0]);

        // Create an x-axis connected to the x scale
        const xAxis = d3.axisBottom()
            .scale(xScale)
            .ticks(5);
        //Define Y axis
        const yAxis = d3.axisLeft()
            .scale(yScale)
            .ticks(5);

        // Define axis for the pillar plot
        const pxScale = d3.scaleLinear()
            .range([0, pillarPlot.width]);
        const pyScale = d3.scaleBand()
            .range([0, pillarPlot.height])
            .domain(pillarNames);
        // Defining axes for pillar plot
        const pxAxis = d3.axisBottom()
            .scale(pxScale);
        const pyAxis = d3.axisLeft()
            .scale(pyScale);

        var historyPoints = plot.canvas.append("g").attr("id", "history-bubbles");
        var plotPoints = plot.canvas.append("g").attr("id", "bubbles");
        var historyLabels = plot.canvas.append("g").attr("id", "history-labels");
        var plotLabels = plot.canvas.append("g").attr("id", "labels");
        var legend = plot.canvas.append("g")
            .attr("transform", "translate(" + plot.legend_offset + ",0)").attr("id", "legend");

        var pillarBars = pillarPlot.canvas.append("g").attr("id", "pillar-bars");


        const ColorPalett = ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17'];

        var highestPillar = -1;

        class Country {
            constructor(entries) {
                this.region = entries[0]['Region'];
                this.income_group = entries[0]['Income group'];
                this.classification = entries[0]['Forum classification'];
                this.name = entries[0]['Country'];
                this.yearlyData = {}
                this._selected = false;
                entries.forEach(entry => {
                    var year = entry['Year']
                    this.yearlyData[year] = {
                        name: this.name,
                        year: parseInt(year),
                        population: parseInt(entry['Population']),
                        gdp: parseInt(entry['GDP']),
                        global_competitiveness: parseFloat(entry['Global_Competitiveness_Index']),
                        pillars: {}
                    }
                    for (var key in entry) {
                        if (key.includes('_pillar_')) {
                            var value = parseFloat(entry[key]);
                            if (!isNaN(value) && value > highestPillar) {
                                highestPillar = value;
                            }
                            this.yearlyData[year].pillars[key] = {
                                pillar: key,
                                value: parseFloat(entry[key])
                            }
                        }
                    }
                });
            }

            get circle() {
                return d3.select("#" + this.circleId);
            }

            get label() {
                return d3.select("#" + this.labelId);
            }

            overHistory(data) {
                d3.select("#" + this.labelId + data.year)
                    .classed("hovered", true);
            }

            outHistory(data) {
                historyLabels.selectAll("text").classed("hovered", false);
            }

            get circleId() {
                return 'circle_' + this.name.replace(/[^a-zA-Z]/g, "");
            }

            get labelId() {
                return 'label_' + this.name.replace(/[^a-zA-Z]/g, "");
            }

            transform(year) {
                return "translate(" + scaleX(this.getGdp(year)) + "," + scaleY(this.getCompetitiveness(
                    year)) + ")";
            }


            getCompetitiveness(year) {
                return this.yearlyData[year].global_competitiveness;
            }

            getPopulation(year) {
                return this.yearlyData[year].population;
            }

            getGdp(year) {
                return this.yearlyData[year].gdp;
            }

            getMax(key) {
                var max = -1;
                for (var year in this.yearlyData) {
                    if (this.yearlyData[year][key] > max) {
                        max = this.yearlyData[year][key];
                    }
                }
                return max;
            }

            getMin(key) {
                var min = -1;
                for (var year in this.yearlyData) {
                    if (!isNaN(this.yearlyData[year][key]) && (this.yearlyData[year][key] < min || min == -1)) {
                        min = this.yearlyData[year][key];
                    }
                }
                return min;
            }

            isDataComplete(year) {
                if (year in this.yearlyData) {
                    var data = this.yearlyData[year];
                    return !isNaN(data.global_competitiveness) && !isNaN(data.gdp) && !isNaN(data.population);
                } {
                    return false;
                }
            }
        }

        function getMin(countries, key) {
            return Math.min(...countries.map(country => country.getMin(key)));
        }

        function getMax(countries, key) {
            return Math.max(...countries.map(country => country.getMax(key)));
        }

        function groupBy(array, key) {
            return array.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };

        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }

        var minComp, maxComp, minGdp, maxGdp, minYear, maxYear, year, yearScale, controlHandle, playButton;
        var countries;
        var colorMap = {};

        d3.csv('./GCI_CompleteData2.csv', data => {
            var grouped = groupBy(data, 'Country');
            countries = []
            for (var name in grouped) {
                countries.push(new Country(grouped[name]));
            }

            minGdp = getMin(countries, 'gdp');
            maxGdp = getMax(countries, 'gdp');
            minGdp = 100;
            maxGdp = 4000000;
            minComp = getMin(countries, 'global_competitiveness');
            maxComp = getMax(countries, 'global_competitiveness');
            minComp = 2.5;
            maxComp = 6;
            minYear = getMin(countries, 'year');
            maxYear = getMax(countries, 'year');
            // console.log(minComp, maxComp, minGdp, maxGdp);
            // console.log(xScale(maxGdp))

            // Setting up the axis
            xScale.domain([minGdp, maxGdp]);
            yScale.domain([minComp, maxComp]);

            // Create the x-axis
            plot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "x-axis")
                .attr("transform", "translate(0," + plot.height + ")")
                .call(xAxis);

            // Create the y axis
            plot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "y-axis")
                .call(yAxis);


            plot.canvas.append("text")
                .attr("transform",
                    "translate(" + (plot.width / 2) + " ," +
                    (plot.height + plot.margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text("GDP");

            plot.canvas.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - plot.margin.left)
                .attr("x", 0 - (plot.height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Gloabl competitiveness");


            // Create the pilalr x axis
            pxScale.domain([0, Math.ceil(highestPillar)]);
            pxAxis.ticks(Math.ceil(highestPillar));

            pillarPlot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "pillar-x-axis")
                .attr("transform", "translate(0," + pillarPlot.height + ")")
                .call(pxAxis);

            // Create the pillar y axis
            pillarPlot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "pillar-y-axis")
                .call(pyAxis);

            pillarPlot.canvas.append("text")
                .attr("transform",
                    "translate(" + (pillarPlot.width / 2) + " ," +
                    (pillarPlot.height + pillarPlot.margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text("Value");

            // Setting up the colors
            var regions = countries.map(c => c.classification).filter(onlyUnique);
            for (var i = 0; i < regions.length; i++) {
                colorMap[regions[i]] = ColorPalett[i];
            }


            // Build legend to the left
            var enteredLegend = legend.selectAll("g")
                .data(regions)
                .enter();

            enteredLegend.append("circle")
                .attr("cy", (region, i) => i * 25 + 10)
                .attr("fill", region => colorMap[region])
                .classed("legend-circle", true);

            enteredLegend.append("text")
                .attr("class", "legend")
                .text(region => region)
                .attr("y", (region, i) => i * 25 + 17)
                .attr("x", 15);


            //Setup control
            yearScale = d3.scaleLinear()
                .domain([minYear, maxYear])
                .range([0, control.width - control.lineOffset]);

            var slider = control.canvas.append("g")
                .attr("transform", "translate(" + 50 + ", 0)")
                .classed("slider", true);

            slider.append("line")
                .attr("x1", yearScale.range()[0])
                .attr("x1", yearScale.range()[1])
                .call(d3.drag()
                    .on("start drag", () => {
                        var x = d3.event.x + yearScale.range()[1] / (maxYear - minYear) / 2;
                        var newYear = parseInt(yearScale.invert(x));
                        playPause(false);
                        generateVis(newYear, selected);
                    }));

            controlHandle = slider.append("circle");

            slider.append("g")
                .attr("transform", "translate(0," + 36 + ")")
                .selectAll("text")
                .data(yearScale.ticks(maxYear - minYear))
                .enter()
                .append("text")
                .attr("x", yearScale)
                .text(d => d);

            playButton = control.canvas.append("g")
                .classed("play-btn", true);
            playButton.append("circle");
            playButton.append("text")
                .text("▶")
                .on('click', () => {
                    playPause();
                });

            generateVis(minYear, countries[30]);
        });

        function scaleX(gdp) {
            return plot.width * Math.log(gdp / minGdp) / Math.log(maxGdp / minGdp);
        }

        function scaleY(comp) {
            return plot.height - plot.height * (comp - minComp) / (maxComp - minComp);
        }

        function scaleR(population) {
            return Math.sqrt(population) / (1000000 / plot.width);
        }

        function startHover(country) {
            country.circle.classed("hovered", true);
            country.label.classed("hovered", true);
            plotPoints.selectAll("circle").classed("blend-out", true);
            country.circle.classed("blend-out", false);
        }

        function stopHover(country) {
            plotPoints.selectAll("circle")
                .classed("hovered", false)
                .classed("blend-out", false);
            plotLabels.selectAll("text")
                .classed("hovered", false);
        }

        var selected = undefined;
        const selection = [];

        function isIn(array, value) {
            return array.indexOf(value) > -1;
        }

        function onClickCountry(country) {
            if (country == selected || isIn(selection, country)) {
                generateVis(year, null);
            } else {
                generateVis(year, country);
            }
        }

        function generateVis(newYear, newSelected) {
            if ((newYear == year || newYear < minYear || newYear > maxYear) && (newSelected == selected))
                return;
            selected = newSelected;
            if (isIn(selection, newSelected)) {
                selection.splice(selection.indexOf(newSelected), 1);
            } else {
                selection.push(newSelected);
            }
            year = newYear;
            controlHandle.transition()
                .attr("cx", yearScale(year));

            drawMainVis();
            drawPillars();
            drawHistory();
        }

        function drawMainVis() {
            var currentCountries = countries.filter(country => country.isDataComplete(year));

            var points = plotPoints.selectAll("circle")
                .data(currentCountries, country => country.name);

            // Add Point
            points.enter()
                .append("circle")
                .attr("id", country => country.circleId)
                .classed("country-circle", true)
                .on("mouseover", startHover)
                .on("mouseout", stopHover)
                .on("click", onClickCountry)
                .attr("transform", country => country.transform(year))
                .style("fill", country => colorMap[country.classification])
                .merge(points) // Set attributes for all bubbles
                .attr("r", country => scaleR(country.getPopulation(year)))
                .attr("transform", country => country.transform(year))
                .classed('selected', country => selected == country);

            // Add Text
            var labels = plotLabels.selectAll("text")
                .data(currentCountries, country => country.name);

            labels.enter()
                .append("text")
                .attr("id", country => country.labelId)
                .text(country => country.name)
                .classed("country-label", true)
                .merge(labels) // Set attributes for all labels
                .attr("transform", country => country.transform(year))
                .classed('selected', country => selected == country);

            points.exit()
                .transition()
                .duration(200)
                .attr("r", 0)
                .remove();
            labels.exit()
                .remove();
        }

        function drawPillars() {
            // Pillars
            var pillarData;
            if (selected != null && year in selected.yearlyData) {
                pillarData = [].concat.apply([], selection.map((country, ind) => Object.values(country.yearlyData[year].pillars).map((data, i) => {
                    return {
                        country : country.name,
                        country_index : ind,
                        index : i,
                        ...data
                    };
                })));
            } else {
                pillarData = [];
            }

            var nSelection = selection.length;

            var pillars = pillarBars.selectAll("rect")
                .data(pillarData, p => p.pillar);

            var pillarHeight = pillarPlot.height / 15 / nSelection;

            pillars.enter()
                .append("rect")
                .classed("pillar", true)
                .attr("x", 0)
                .attr("height", pillarHeight)
                .merge(pillars) // Set attributes for all pillars
                .transition()
                .duration(200)
                .attr("height", pillarHeight)
                .attr("y", (p, i) => p.index * pillarPlot.height / 12 + pillarHeight*p.country_index + pillarHeight*nSelection/8)
                .attr("width", p => p.value * pillarPlot.width / highestPillar);

            pillars.exit()
                .transition()
                .duration(200)
                .attr("width", 0)
                .remove();
        }

        function drawHistory() {
            if (selected == null) {
                historyPoints.selectAll("circle").remove();
                historyLabels.selectAll("text").remove();
                return;
            }
            var hisData = Object.values(selected.yearlyData).filter(data => selected.isDataComplete(data.year));
            var hisPoints = historyPoints.selectAll("circle")
                .data(hisData, data => data.name + data.year);
            var hisLabels = historyLabels.selectAll("text")
                .data(hisData, data => data.name + data.year);


            hisPoints.enter()
                .append("circle")
                .attr("id", data => selected.circleId + data.year)
                .attr("transform", data => selected.transform(data.year))
                .classed("country-circle", true)
                .classed("country-history", true)
                .on("mouseover", data => selected.overHistory(data))
                .on("mouseout", data => selected.outHistory(data))
                .on("click", () => selected.selected = false)
                .transition()
                .duration(200)
                .attr("r", data => scaleR(data.population))
                .style("opacity", data => (data.year - minYear) / (maxYear - minYear) / 2 + 0.3)
                .style("fill", colorMap[selected.classification]);

            hisLabels.enter()
                .append("text")
                .attr("id", data => selected.labelId + data.year)
                .text(data => selected.name + " " + data.year)
                .attr("transform", data => selected.transform(data.year))
                .classed("country-label", true)
                .classed("country-history", true);

            hisPoints.exit()
                .transition()
                .duration(200)
                .attr("r", 0)
                .remove();
            hisLabels.exit().remove();
        }

        var timer = -1;

        function playPause(play = undefined) {
            if ((timer == -1 && play === undefined) || play === true) {
                var nextYear = year < maxYear ? year + 1 : minYear;
                timer = setInterval(() => {
                    generateVis(nextYear, selected);
                    nextYear += 1;
                    if (nextYear > maxYear) {
                        playPause();
                    }
                }, 500);
                playButton.select("text").text("❚❚");
            } else {
                clearInterval(timer);
                timer = -1;
                playButton.select("text").text("▶");
            }
        }
    </script>
</body>

</html>