<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Channeling Hans</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="main.css" />
    <script src="d3/d3.v4.js"></script>
</head>

<body>
    <div id="visualizations">
    </div>
    <script>
        // Setting the used color pallets for different regions
        const ColorPalett = ['#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9'];
        // Setting colors for selection
        const SelectionColors = ['#8dd3c7', '#ffffb3'];
        // Defining the dimensions of the main plot
        const plot = {
            outer_width: 1000,
            outer_height: 750,
            margin: {
                top: 10,
                right: 10,
                bottom: 50,
                left: 50
            },
            legend_offset: 20,
            width: 0,
            height: 0,
            canvas: null
        };
        // Defining the dimensions of the pillar plot
        const pillarPlot = {
            outer_height: plot.outer_height,
            outer_width: 400,
            margin: {
                top: 90,
                right: 25,
                bottom: 50,
                left: 190
            },
            legend_margin: {
                top: 60,
                left: 20
            },
            title_margin: {
                top: 10,
            },
            width: 0,
            height: 0,
            canvas: null
        }
        // Defining the dimensions of the control bar
        const control = {
            outer_width: plot.outer_width,
            outer_height: 100,
            margin: {
                top: 25,
                right: 25,
                bottom: 10,
                left: 25
            },
            lineOffset: 50,
            width: 0,
            height: 0,
            canvas: null
        }
        // Defining all keys of the given data (avoid bugs through constants)
        const keys = {
            country: 'Country',
            population: 'Population',
            competitiveness: 'Global_Competitiveness_Index',
            gdp: 'GDP',
            incomeGroup: 'Income group',
            year: 'Year',
            region: 'Region',
            classification: 'Forum classification',
            pillars: [
                '1st_pillar_Institutions', '2nd_pillar_Infrastructure', '3rd_pillar_Macroeconomic_environment',
                '4th_pillar_Health_and_primary_education', '5th_pillar_Higher_education_and_training',
                '6th_pillar_Goods_market_efficiency', '7th_pillar_Labor_market_efficiency',
                '8th_pillar_Financial_market_development', '9th_pillar_Technological_readiness',
                '10th_pillar_Market_size', '11th_pillar_Business_sophistication_', '12th_pillar_Innovation'
            ],
        }
        // Define human readable names for all pillars
        const pillarNames = [
            'Insitutions',
            'Infrastructure',
            'Macroeconimic environment',
            'Health & primary education',
            'Higher education & training',
            'Goods market efficiency',
            'Labor market efficiency',
            'Financial market development',
            'Technological readiness',
            'Market size',
            'Business sophistication',
            'Innovation'
        ]
        // Generate a svg element based on the given dimensions
        function generateSvgCanvas(dims, parent) {
            dims.width = dims.outer_width - dims.margin.left - dims.margin.right;
            dims.height = dims.outer_height - dims.margin.top - dims.margin.bottom;

            dims.svg = d3.select(parent)
                .append("svg")
                .attr("width", dims.outer_width)
                .attr("height", dims.outer_height);
            dims.canvas = dims.svg.append("g")
                .attr("transform", "translate(" + dims.margin.left + "," + dims.margin.top + ")");
        }
        // Generate a canvas for all elements
        generateSvgCanvas(plot, "#visualizations");
        generateSvgCanvas(pillarPlot, "#visualizations");
        generateSvgCanvas(control, "body");
        // Set the width of the visualization container to ensure that the main plot and pillar plot are displayed in one row
        d3.select("#visualizations").style("width", plot.outer_width + pillarPlot.outer_width + 'px');

        // Set up the scale to be used on the x axis
        const xScale = d3.scaleLog()
            .range([0, plot.width]);
        // Set up the scale to be used on the y axis
        const yScale = d3.scaleLinear()
            .range([plot.height, 0]);

        // Create an x-axis connected to the x scale
        const xAxis = d3.axisBottom()
            .scale(xScale)
            .ticks(5)
            .tickFormat(d => xScale.tickFormat(4, d3.format(",d"))(d));
        //Define Y axis
        const yAxis = d3.axisLeft()
            .scale(yScale)
            .ticks(5);

        // Define scales for the pillar plot
        const pxScale = d3.scaleLinear()
            .range([0, pillarPlot.width]);
        const pyScale = d3.scaleBand()
            .range([0, pillarPlot.height])
            .domain(pillarNames);
        // Defining axes for pillar plot
        const pxAxis = d3.axisBottom()
            .scale(pxScale);
        const pyAxis = d3.axisLeft()
            .scale(pyScale);

        // Define container for several elements in the main plot
        var readingHelp = plot.canvas.append("g").attr("id", "reading-help");
        var historyPoints = plot.canvas.append("g").attr("id", "history-bubbles");
        var plotPoints = plot.canvas.append("g").attr("id", "bubbles");
        var plotLabels = plot.canvas.append("g").attr("id", "labels");
        var historyLabels = plot.canvas.append("g").attr("id", "history-labels");
        var legend = plot.canvas.append("g")
            .attr("transform", "translate(" + plot.legend_offset + ",0)").attr("id", "legend");

        // Setup the x label
        plot.canvas.append("text")
            .attr("transform",
                `translate(${plot.width / 2}, ${plot.height + plot.margin.top + 40})`)
            .style("text-anchor", "middle")
            .text("GDP");

        // Setup the y label
        plot.canvas.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - plot.margin.left)
            .attr("x", 0 - (plot.height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Gloabl competitiveness");

        // Define container for several elements in the pillar plot
        var pillarBars = pillarPlot.canvas.append("g").attr("id", "pillar-bars");
        var pillarLegend = pillarPlot.svg.append("g")
            .attr("id", "pillar-legend")
            .attr("transform", "translate(" + pillarPlot.legend_margin.left + "," + pillarPlot.legend_margin.top + ")");
        // Add title for this plot
        pillarPlot.svg.append("text")
            .text("Competitiveness breakdown")
            .classed("title", true)
            .attr("x", pillarPlot.outer_width / 2)
            .attr("y", pillarPlot.title_margin.top);

        // Variable which is used during readin to capture the highest pillar
        var highestPillar = -1;

        // This class represents a country. It eases the access to fixed fields like region, name or classification and contains a dictionary with all yearly specific data.
        class Country {
            // The parameter entries is an array of all csv rows which belong to this country.
            constructor(entries) {
                this.region = entries[0][keys.region];
                this.income_group = entries[0][keys.incomeGroup];
                this.classification = entries[0][keys.classification];
                this.name = entries[0][keys.country];
                this.yearlyData = {}
                // Setup yearly data from given array
                entries.forEach(entry => {
                    var year = entry[keys.year]
                    // Copy the given entry and 
                    var data = Object.assign({}, entry);

                    for (var key in data) {
                        var val = parseFloat(data[key]);
                        data[key] = val;
                        if (keys.pillars.indexOf(key) >= 0) {
                            if (val > highestPillar) {
                                highestPillar = val;
                            }
                        }
                    }
                    // Add reference this country
                    data.country = this;
                    this.yearlyData[year] = data;
                });
            }

            // Get the main bubble
            get circle() {
                return this.getCircle(null);
            }

            // Returns the history bubble for the specified year. If year==null the main bubble is returned
            getCircle(year) {
                return d3.select(`#${this.getCircleId(year)}`);
            }

            // Get the main label
            get label() {
                return this.getLabel(null);
            }

            // Returns the history labels for the specified year. If year==null the main label is returned
            getLabel(year) {
                return d3.select(`#${this.getLabelId(year)}`);
            }

            //Return the bounding box of the history label for year. If year==null the main label is used.
            getLabelBB(year) {
                return this.getLabel(year).select("text").node().getBBox();
            }

            //Returns the id of the main bubble
            get circleId() {
                return 'circle_' + this.name.replace(/[^a-zA-Z]/g, "");
            }

            // Return the id of the main label
            get labelId() {
                return 'label_' + this.name.replace(/[^a-zA-Z]/g, "");
            }

            // Returns the id for the history bubble of the given year
            getCircleId(year) {
                return this.circleId + (year == null ? '' : year);
            }

            // Returns the id for the history label of the given year
            getLabelId(year) {
                return this.labelId + (year == null ? '' : year);
            }

            // Return the transform for bubble at the given year
            transform(year) {
                var x = scaleX(this.getValue(year, keys.gdp));
                var y = scaleY(this.getValue(year, keys.competitiveness));
                return `translate(${x},${y})`;
            }

            // Return the transform for label at the given year
            labelTransform(year) {
                var x = scaleX(this.getValue(year, keys.gdp));
                var y = scaleY(this.getValue(year, keys.competitiveness));
                var r = scaleR(this.getValue(year, keys.population));
                return `translate(${x-r}, ${y-r})`;
            }

            // Return the radius for the given year
            radius(year) {
                return scaleR(this.getValue(year, keys.population));
            }

            // Helper function which returns the index of the next higher year which is not NaN for the specified attribute.
            _upperBound(years, index, key) {
                if (index == years.length - 1) {
                    return -1;
                }
                while (++index < years.length && isNaN(this.yearlyData[years[index]][key]));
                if (index == years.length) {
                    return -1;
                }
                return index;
            }

            // Helper function which returns the index of the next lower year which is not NaN for the specified attribute.
            _lowerBound(years, index, key) {
                if (index == 0) {
                    return -1;
                }
                while (--index >= 0 && isNaN(this.yearlyData[years[index]][key]));
                return index;
            }

            // Returns the value for the specified key for the given year. If the year has no value for the given key it is linearly interpolated between its neighbors which have keys. If one neighbor is mising the other is returned as result.
            getValue(year, key) {
                if (!isNaN(this.yearlyData[year][key])) {
                    return this.yearlyData[year][key];
                }
                var years = Object.keys(this.yearlyData);
                // Getting the index of the current year
                var index = years.indexOf(year.toString());
                // Finding both bounds
                var lowerBound = this._upperBound(years, index, key);
                var upperBound = this._lowerBound(years, index, key)
                // Check if any of them is not present
                if (lowerBound == -1) {
                    return this.yearlyData[years[upperBound]][key];
                }
                if (upperBound == -1) {
                    return this.yearlyData[years[lowerBound]][key];
                }
                // retrieve values
                var lowerYear = years[lowerBound];
                var upperYear = years[upperBound];
                var lowerValue, upperValue;
                lowerValue = this.yearlyData[lowerYear][key];
                upperValue = this.yearlyData[upperYear][key];
                // Linear interpolation
                var result = (year - lowerYear) / (upperYear - lowerYear) * (upperValue - lowerValue) + lowerValue;
                return result;
            }

            // Returns the highest value for a given key
            getMax(key) {
                var max = -1;
                for (var year in this.yearlyData) {
                    if (this.yearlyData[year][key] > max) {
                        max = this.yearlyData[year][key];
                    }
                }
                return max;
            }

            // Returns the lowest value for a given key
            getMin(key) {
                var min = -1;
                for (var year in this.yearlyData) {
                    if (!isNaN(this.yearlyData[year][key]) && (this.yearlyData[year][key] < min || min == -1)) {
                        min = this.yearlyData[year][key];
                    }
                }
                return min;
            }
            
            // Returns true of data for a given year is provided
            hasYear(year) {
                return year in this.yearlyData;
            }
        }

        // Some variables which are set later on
        var minComp, maxComp, minGdp, maxGdp, minYear, maxYear, year, yearScale, controlHandle, playButton, countries;
        // Color map which maps country classification to a color
        var colorMap = {};

        // Loading the dataset
        d3.csv('./GCI_CompleteData2.csv', data => {
            // Group dataset by country
            var grouped = groupBy(data, keys.country);
            // Construct all countries
            countries = [];
            for (var name in grouped) {
                countries.push(new Country(grouped[name]));
            }
            
            // Define lowre and upper bounds
            // The hardcoded results are personally chosen to provide a better overview
            minGdp = getMin(countries, keys.gdp);
            maxGdp = getMax(countries, keys.gdp);
            minGdp = 50;
            maxGdp = 4000000;
            minComp = getMin(countries, keys.competitiveness);
            maxComp = getMax(countries, keys.competitiveness);
            minComp = 2.5;
            maxComp = 6;
            minYear = getMin(countries, keys.year);
            maxYear = getMax(countries, keys.year);
            minYear = 2007;
            maxYear = 2017;

            // Setting up the axis scales
            xScale.domain([minGdp, maxGdp]);
            yScale.domain([minComp, maxComp]);

            // Create the x-axis
            plot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "x-axis")
                .attr("transform", `translate(0, ${plot.height})`)
                .call(xAxis);

            // Create the y axis
            plot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "y-axis")
                .call(yAxis);

            // Create the pillar x axis
            pxScale.domain([0, Math.ceil(highestPillar)]);
            pxAxis.ticks(Math.ceil(highestPillar));

            pillarPlot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "pillar-x-axis")
                .attr("transform", "translate(0," + pillarPlot.height + ")")
                .call(pxAxis);

            // Create the pillar y axis
            pillarPlot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "pillar-y-axis")
                .call(pyAxis);

            pillarPlot.canvas.append("text")
                .attr("transform",
                    `translate(${pillarPlot.width / 2},
                    ${pillarPlot.height + pillarPlot.margin.top + 20})`
                )
                .style("text-anchor", "middle")
                .text("Value");

            // Setting up the colors
            var regions = countries.map(c => c.classification).filter(unique);
            for (var i = 0; i < regions.length; i++) {
                colorMap[regions[i]] = ColorPalett[i];
            }


            // Build legend to the left
            var enteredLegend = legend.selectAll("g")
                .data(regions)
                .enter();

            enteredLegend.append("circle")
                .attr("cy", (region, i) => i * 25 + 10)
                .attr("r", 7.5)
                .attr("fill", region => colorMap[region])
                .classed("legend-circle", true);

            enteredLegend.append("text")
                .classed("legend", true)
                .text(region => region)
                .attr("y", (region, i) => i * 25 + 10);


            //Setup control
            //Create scale for years
            yearScale = d3.scaleLinear()
                .domain([minYear, maxYear])
                .range([0, control.width - control.lineOffset]);
            //Create slider
            var slider = control.canvas.append("g")
                .attr("transform", `translate(50, 0)`)
                .classed("slider", true);

            slider.append("line")
                .attr("x1", yearScale.range()[0])
                .attr("x1", yearScale.range()[1])
                .call(d3.drag()
                    .on("start drag", () => {
                        var x = d3.event.x + yearScale.range()[1] / (maxYear - minYear) / 2;
                        var newYear = parseInt(yearScale.invert(x));
                        playPause(false);
                        if (newYear != year)
                            generateVis(newYear, selection);
                    }));
            // Create control handle
            controlHandle = slider.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", 15);
            // Create slider legend
            slider.append("g")
                .attr("transform", `translate(0, 36)`)
                .selectAll("text")
                .data(yearScale.ticks(maxYear - minYear))
                .enter()
                .append("text")
                .attr("x", yearScale)
                .text(d => d);

            // Create the play/pause button
            playButton = control.canvas.append("g")
                .classed("play-btn", true);

            playButton.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", 18);
            playButton.append("text")
                .text("▶")
                .on('click', () => {
                    playPause();
                });
            // Generate first visualization
            generateVis(minYear, []);
        });

        // Maps an gdp value to its position on the x-axis. Mind the logartihmic scale
        function scaleX(gdp) {
            return plot.width * Math.log(gdp / minGdp) / Math.log(maxGdp / minGdp);
        }

        // Maps a competitiveness score to its position on the y-axis.
        function scaleY(comp) {
            return plot.height - plot.height * (comp - minComp) / (maxComp - minComp);
        }

        // Returns the radius of a circle where the circle area is proportional to the provided population.
        function scaleR(population) {
            return Math.sqrt(population) / (750000 / plot.width);
        }

        // Returns the color for the stroke around bubbles. If a bubble is selected its stroke should change.
        function strokeColor(country) {
            return isSelected(country) ?
                SelectionColors[selection.length - 1 - selection.indexOf(country)] :
                "black";
        }

        // Function which is called whenever the user hovers over any bubble.
        // newHoveredYear is only used when the uesr hovers over history bubbles.
        function startHover(country, newHoveredYear) {
            // If years are identical set to no year provided.
            if (newHoveredYear == year) {
                hoveredYear = null;
            } else {
                hoveredYear = newHoveredYear;
            }
            hovered = country;
            // Set hovered state for the hovered item
            country.getCircle(hoveredYear)
                .classed("hovered", true);
            country.getLabel(hoveredYear)
                .classed("hovered", true);
            // Blen out all other items
            plotPoints.selectAll("circle")
                .classed("blend-out", true);
            historyPoints.selectAll("circle")
                .classed("blend-out", true);
            country.getCircle(hoveredYear)
                .classed("blend-out", false);
            
            // Draw the reading help
            drawReadingHelp();
        }

        // This function is called whenever a country loses its hover state.
        function stopHover(country) {
            hovered = null;
            hoveredYear = null;
            // Remove all hovered and blend-out states
            plotPoints.selectAll("circle")
                .classed("hovered", false)
                .classed("blend-out", false);

            historyPoints.selectAll("circle")
                .classed("hovered", false)
                .classed("blend-out", false);

            plotLabels.selectAll("g")
                .classed("hovered", false);
            historyLabels.selectAll("g")
                .classed("hovered", false);

            drawReadingHelp();
        }

        // Variables for hover and selection
        var hoveredYear = null;
        var hovered = null;
        var selection = [];

        // Returns true if the provided country is currently selected
        function isSelected(country) {
            return isIn(selection, country);
        }

        // Removes an country from selection
        function removeSelection(country) {
            if (isSelected(country)) {
                selection.splice(selection.indexOf(country), 1);
                generateVis(year, selection);
            }
        }

        // Adds a country to selection. If the selection exceeds its limit the first item will be removed.
        function addSeelction(country) {
            if (!isSelected(country)) {
                if (selection.length >= SelectionColors.length) {
                    selection.shift();
                }
                selection.push(country);
                generateVis(year, selection);
            }
        }

        // Handles what happens if a user clicks on a country
        function onClickCountry(country) {
            if (isSelected(country)) {
                removeSelection(country);
            } else {
                addSeelction(country);
            }
        }
        
        // Generates the whole visualization with all subvisualizations
        function generateVis(newYear, newSelection) {
            // If the year is not valid return
            if (newYear < minYear || newYear > maxYear)
                return;
            selection = newSelection;
            year = newYear;
            // Update control handle position
            controlHandle.transition()
                .attr("cx", yearScale(year));

            // Draw all sub visualizations
            drawMainVis();
            drawPillars();
            drawHistory();
            drawReadingHelp();
        }

        // Returns the length of the line for the label for the specified year and country
        function labelPointerPos(country, year) {
            var r = country.radius(year);
            var l = Math.sqrt(2 * r * r) - r;
            return l;
        }

        function drawMainVis() {
            var currentCountries = countries.filter(country =>
                    country.hasYear(year))
                .sort((c1, c2) =>
                    c2.getValue(year, keys.population) - c1.getValue(year, keys.population));


            var points = plotPoints.selectAll("circle")
                .data(currentCountries, country => country.name);

            // Add Point
            points.enter()
                .append("circle")
                .attr("id", country => country.circleId)
                .classed("country-circle", true)
                .on("mouseover", c => startHover(c, null))
                .on("mouseout", c => stopHover(c))
                .on("click", onClickCountry)
                .attr("transform", country => country.transform(year))
                .style("fill", country => colorMap[country.classification])
                .merge(points) // Set attributes for all bubbles
                .classed('selected', isSelected)
                .transition()
                .duration(200)
                .attr("r", country => country.radius(year))
                .attr("transform", country => country.transform(year))
                .attr("stroke", strokeColor);

            // Add Text
            var labels = plotLabels.selectAll("g")
                .data(currentCountries, country => country.name);

            labels.classed('selected', isSelected)
                .transition()
                .duration(200)
                .attr("transform", country => country.labelTransform(year));

            var entered = labels.enter()
                .append("g")
                .attr("id", c => c.labelId)
                .classed("country-label", true)
                .attr("transform", c => c.labelTransform(year));

            entered.append("text")
                .text(c => c.name);

            var pad_x = 10;
            var pad_y = 5;

            entered.insert("rect", ":first-child")
                .attr("width", c => c.getLabelBB(null).width + pad_x)
                .attr("height", c => c.getLabelBB(null).height + pad_y)
                .attr("x", c => -(c.getLabelBB(null).width + pad_x / 2))
                .attr("y", c => -(c.getLabelBB(null).height + pad_y) / 2)
                .attr("rx", 3)
                .attr("ry", 3);

            entered.insert("line", ":first-child")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", c => labelPointerPos(c, year))
                .attr("y2", c => labelPointerPos(c, year));

            points.exit()
                .transition()
                .duration(200)
                .attr("r", 0)
                .remove();
            labels.exit()
                .remove();
        }

        function drawReadingHelp() {
            var _year = hoveredYear == null ? year : hoveredYear;
            var data = hovered == null ? [] : [0, 1];
            var lines = readingHelp.selectAll("line")
                .data(data);
            var values = readingHelp.selectAll("text")
                .data(data);

            if (hovered != null) {
                var x_val = hovered.getValue(_year, keys.gdp)
                var x = scaleX(x_val);
                var y_val = hovered.getValue(_year, keys.competitiveness);
                var y = scaleY(y_val);
            }

            lines.enter()
                .insert("line", ":first-child")
                .merge(lines)
                .attr("x1", d => d * x)
                .attr("y1", d => d == 0 ? y : plot.height)
                .attr("x2", x)
                .attr("y2", y)
                .attr("stroke", "black")
                .attr("stroke-dasharray", "5, 5");

            values.enter()
                .insert("text", ":first-child")
                .merge(values)
                .attr("x", d => d * x)
                .attr("y", d => d == 0 ? y : plot.height)
                .text(d => Math.round((d == 0 ? y_val : x_val) * 10) / 10)
                .attr("text-anchor", d => d == 0 ? "end" : "middle")
                .attr("transform", d => `translate(${8*(d-1)}, ${d*30})`);

            lines.exit().remove();
            values.exit().remove();
        }

        function drawPillars() {
            // Pillars
            var reverseSel = selection.slice().reverse();
            // Selecting the data to visualize
            var pillarData = reverseSel.filter(c => c.hasYear(year)).map((c, ind) =>
                keys.pillars.map((name, i) => {
                    return {
                        value: c.getValue(year, name),
                        pillar: name,
                        index: i,
                        country_index: ind,
                        country: c
                    }
                }));
            // Flatten
            pillarData = [].concat.apply([], pillarData);

            var nSelection = selection.length;

            var pillars = pillarBars.selectAll("rect")
                .data(pillarData, p => p.pillar + p.country.name);

            var pillarHeight = pillarPlot.height / 15 / nSelection;

            pillars.enter()
                .append("rect")
                .classed("pillar", true)
                .attr("x", 0)
                .attr("y", (p, i) => p.index * pillarPlot.height / 12 + pillarHeight * p.country_index + pillarHeight *
                    nSelection / 8)
                .attr("stroke", "black")
                .merge(pillars) // Set attributes for all pillars
                .attr("fill", d => strokeColor(d.country))
                .transition()
                .delay((p, i) => i * 10)
                .duration(150)
                .attr("height", pillarHeight)
                .attr("x", 0.5) // moving it 0.5 to the right to compensate for the border
                .attr("y", (p, i) => p.index * pillarPlot.height / 12 + pillarHeight * p.country_index + pillarHeight *
                    nSelection / 8)
                .attr("width", p => p.value * pillarPlot.width / highestPillar - 1); // -1 to compensate the stroke border

            pillars.exit()
                .transition()
                .delay((p, i) => i * 10)
                .duration(150)
                .attr("width", 0)
                .remove();

            // Draw legend
            var legendCircles = pillarLegend.selectAll("rect")
                .data(reverseSel, (c, i) => i);
            var legendLabels = pillarLegend.selectAll("text")
                .data(reverseSel, (c, i) => c.name);

            legendCircles.enter()
                .append("rect")
                .attr("width", 20)
                .attr("height", 20)
                .classed("legend-rect", true)
                .merge(legendCircles)
                .attr("fill", strokeColor)
                .attr("x", (c, i) => i * (pillarPlot.outer_width - 2 * pillarPlot.legend_margin.left) / 2 + 10);

            legendCircles.exit()
                .transition()
                .duration(200)
                .attr("width", 0)
                .attr("height", 0)
                .style("transform", "translate(10px, 10px)")
                .remove();

            legendLabels.enter()
                .append("text")
                .classed("legend", true)
                .text(c => c.name)
                .attr("x", -200)
                .merge(legendLabels)
                .transition()
                .duration(300)
                .attr("x", (p, i) => i * (pillarPlot.outer_width - 2 * pillarPlot.legend_margin.left) / 2 + 20);

            legendLabels.exit()
                .remove();
        }

        function drawHistory() {
            var selected = selection[selection.length - 1];
            var hisData = []
            if (selected != null) {
                hisData = Object.values(selected.yearlyData);
            }
            var hisPoints = historyPoints.selectAll("circle")
                .data(hisData, data => data.country.name + data[keys.year]);
            var hisLabels = historyLabels.selectAll("g")
                .data(hisData, data => data.country.name + data[keys.year]);

            hisPoints.enter()
                .append("circle")
                .attr("id", data => selected.circleId + data.year)
                .attr("transform", data => selected.transform(data[keys.year]))
                .classed("country-circle", true)
                .classed("country-history", true)
                .on("mouseover", data => startHover(data.country, data[keys.year]))
                .on("mouseout", data => stopHover(data.country))
                .style("opacity", data => (data[keys.year] - minYear) / (maxYear - minYear) / 2 + 0.4)
                .transition()
                .delay((d, i) => i * 50)
                .duration(200)
                .attr("r", data => selected.radius(data[keys.year]))
                .style("fill", data => colorMap[selected.classification]);

            const getLabelBox = year => d3.select("#" + selected.labelId + year).select("text").node().getBBox();

            var entered = hisLabels.enter()
                .append("g")
                .attr("id", data => selected.labelId + data[keys.year])
                .classed("country-label", true)
                .classed("country-history", true)
                .attr("transform", d => selected.labelTransform(d[keys.year]));

            entered.append("text")
                .text(d => d[keys.year]);

            var pad_x = 10;
            var pad_y = 5;

            entered.insert("rect", ":first-child")
                .attr("width", d => d.country.getLabelBB(d[keys.year]).width + pad_x)
                .attr("height", d => d.country.getLabelBB(d[keys.year]).height + pad_y)
                .attr("x", d => -(d.country.getLabelBB(d[keys.year]).width + pad_x / 2))
                .attr("y", d => -(d.country.getLabelBB(d[keys.year]).height + pad_y) / 2)
                .attr("rx", 3)
                .attr("ry", 3);

            entered.insert("line", ":first-child")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", d => labelPointerPos(selected, d[keys.year]))
                .attr("y2", d => labelPointerPos(selected, d[keys.year]));

            hisPoints.exit()
                .interrupt()
                .transition()
                .duration(200)
                .attr("r", 0)
                .remove();
            hisLabels.exit().remove();
        }

        var timer = -1;

        function playPause(play = undefined) {
            if ((timer == -1 && play === undefined) || play === true) {
                var nextYear = year < maxYear ? year + 1 : minYear;
                timer = setInterval(() => {
                    generateVis(nextYear, selection);
                    nextYear += 1;
                    if (nextYear > maxYear) {
                        playPause();
                    }
                }, 1000);
                playButton.select("text").text("❚❚");
            } else {
                clearInterval(timer);
                timer = -1;
                playButton.select("text").text("▶");
            }
        }
        
        // Returns the minimal value across all countries for the given key
        function getMin(countries, key) {
            return Math.min(...countries.map(country => country.getMin(key)));
        }

        // Returns the maximal value across all countries for the given key
        function getMax(countries, key) {
            return Math.max(...countries.map(country => country.getMax(key)));
        }

        // Groups an array based on the provided key
        // This is copied from stackoverflow
        function groupBy(array, key) {
            return array.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };

        // This filters an array to only contain only distinct values
        function unique(value, index, self) {
            return self.indexOf(value) === index;
        }
        
        // Helper function that returns true if a value is present in an array
        function isIn(array, value) {
            return array.indexOf(value) > -1;
        }
    </script>
</body>

</html>