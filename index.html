<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Channeling Hans</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="main.css" />
    <script src="d3/d3.v4.js"></script>
</head>

<body>
    <div id="visualizations">
    </div>
    <script>
        const ColorPalett = ['#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9'];

        const SelectionColors = ['#8dd3c7', '#ffffb3'];
        // Define margins
        const plot = {
            outer_width: 1000,
            outer_height: 750,
            margin: {
                top: 10,
                right: 10,
                bottom: 50,
                left: 50
            },
            legend_offset: 20,
            width: 0,
            height: 0,
            canvas: null
        };

        const pillarPlot = {
            outer_height: plot.outer_height,
            outer_width: 400,
            margin: {
                top: 90,
                right: 25,
                bottom: 50,
                left: 190
            },
            legend_margin: {
                top: 60,
                left: 20
            },
            title_margin: {
                top: 10,
            },
            width: 0,
            height: 0,
            canvas: null
        }

        const control = {
            outer_width: plot.outer_width,
            outer_height: 100,
            margin: {
                top: 25,
                right: 25,
                bottom: 10,
                left: 25
            },
            lineOffset: 50,
            width: 0,
            height: 0,
            canvas: null
        }

        const keys = {
            country: 'Country',
            population: 'Population',
            competitiveness: 'Global_Competitiveness_Index',
            gdp: 'GDP',
            incomeGroup: 'Income group',
            year: 'Year',
            region: 'Region',
            classification: 'Forum classification',
            pillars: [
                '1st_pillar_Institutions', '2nd_pillar_Infrastructure', '3rd_pillar_Macroeconomic_environment',
                '4th_pillar_Health_and_primary_education', '5th_pillar_Higher_education_and_training',
                '6th_pillar_Goods_market_efficiency', '7th_pillar_Labor_market_efficiency',
                '8th_pillar_Financial_market_development', '9th_pillar_Technological_readiness',
                '10th_pillar_Market_size', '11th_pillar_Business_sophistication_', '12th_pillar_Innovation'
            ],
        }

        const pillarNames = [
            'Insitutions',
            'Infrastructure',
            'Macroeconimic environment',
            'Health & primary education',
            'Higher education & training',
            'Goods market efficiency',
            'Labor market efficiency',
            'Financial market development',
            'Technological readiness',
            'Market size',
            'Business sophistication',
            'Innovation'
        ]

        function generateSvgCanvas(dims, parent) {
            dims.width = dims.outer_width - dims.margin.left - dims.margin.right;
            dims.height = dims.outer_height - dims.margin.top - dims.margin.bottom;

            dims.svg = d3.select(parent)
                .append("svg")
                .attr("width", dims.outer_width)
                .attr("height", dims.outer_height);
            dims.canvas = dims.svg.append("g")
                .attr("transform", "translate(" + dims.margin.left + "," + dims.margin.top + ")");
        }

        generateSvgCanvas(plot, "#visualizations");
        generateSvgCanvas(pillarPlot, "#visualizations");
        generateSvgCanvas(control, "body");

        d3.select("#visualizations").style("width", plot.outer_width + pillarPlot.outer_width + 'px');


        // Set up the scale to be used on the x axis
        const xScale = d3.scaleLog()
            .range([0, plot.width]);
        // Set up the scale to be used on the y axis
        const yScale = d3.scaleLinear()
            .range([plot.height, 0]);

        // Create an x-axis connected to the x scale
        const xAxis = d3.axisBottom()
            .scale(xScale)
            .ticks(5);
        //Define Y axis
        const yAxis = d3.axisLeft()
            .scale(yScale)
            .ticks(5);

        // Define axis for the pillar plot
        const pxScale = d3.scaleLinear()
            .range([0, pillarPlot.width]);
        const pyScale = d3.scaleBand()
            .range([0, pillarPlot.height])
            .domain(pillarNames);
        // Defining axes for pillar plot
        const pxAxis = d3.axisBottom()
            .scale(pxScale);
        const pyAxis = d3.axisLeft()
            .scale(pyScale);

        var historyPoints = plot.canvas.append("g").attr("id", "history-bubbles");
        var plotPoints = plot.canvas.append("g").attr("id", "bubbles");
        var historyLabels = plot.canvas.append("g").attr("id", "history-labels");
        var plotLabels = plot.canvas.append("g").attr("id", "labels");
        var legend = plot.canvas.append("g")
            .attr("transform", "translate(" + plot.legend_offset + ",0)").attr("id", "legend");

        var pillarBars = pillarPlot.canvas.append("g").attr("id", "pillar-bars");
        var pillarLegend = pillarPlot.svg.append("g")
            .attr("id", "pillar-legend")
            .attr("transform", "translate(" + pillarPlot.legend_margin.left + "," + pillarPlot.legend_margin.top + ")");

        pillarPlot.svg.append("text")
            .text("Competitiveness breakdown")
            .classed("title", true)
            .attr("x", pillarPlot.outer_width / 2)
            .attr("y", pillarPlot.title_margin.top);

        var highestPillar = -1;

        class Country {

            constructor(entries) {
                this.region = entries[0][keys.region];
                this.income_group = entries[0][keys.incomeGroup];
                this.classification = entries[0][keys.classification];
                this.name = entries[0][keys.country];
                this.yearlyData = {}
                this._selected = false;
                entries.forEach(entry => {
                    var year = entry[keys.year]
                    this.yearlyData[year] = {
                        name: this.name,
                        year: parseInt(year),
                        population: parseInt(entry[keys.population]),
                        gdp: parseInt(entry[keys.gdp]),
                        global_competitiveness: parseFloat(entry[keys.competitiveness]),
                        pillars: {}
                    }
                    for (var key in entry) {
                        if (key.includes('_pillar_')) {
                            var value = parseFloat(entry[key]);
                            if (!isNaN(value) && value > highestPillar) {
                                highestPillar = value;
                            }
                            this.yearlyData[year].pillars[key] = {
                                pillar: key,
                                value: parseFloat(entry[key])
                            }
                        }
                    }
                    this.yearlyData[year] = Object.assign(this.yearlyData[year], entry);
                    for (var key in this.yearlyData[year]) {
                        var val = parseFloat(this.yearlyData[year][key]);
                        this.yearlyData[year][key] = val;
                    }
                });
            }

            get circle() {
                return d3.select("#" + this.circleId);
            }

            get label() {
                return d3.select("#" + this.labelId);
            }

            overHistory(data) {
                d3.select("#" + this.labelId + data.year)
                    .classed("hovered", true);
            }

            outHistory(data) {
                historyLabels.selectAll("text").classed("hovered", false);
            }

            get circleId() {
                return 'circle_' + this.name.replace(/[^a-zA-Z]/g, "");
            }

            get labelId() {
                return 'label_' + this.name.replace(/[^a-zA-Z]/g, "");
            }

            transform(year) {
                var x = scaleX(this.getValue(year, keys.gdp));
                var y = scaleY(this.getValue(year, keys.competitiveness));
                if (x < -100000) {
                    console.log(this.getValue(year, keys.gdp));
                    console.log(x);
                }
                return `translate(${x},${y})`;
            }

            upperBound(years, index, key) {
                if (index == years.length - 1) {
                    return -1;
                }
                while (++index < years.length && isNaN(this.yearlyData[years[index]][key]));
                if (index == years.length) {
                    return -1;
                }
                return index;
            }

            lowerBound(years, index, key) {
                if (index == 0) {
                    return -1;
                }
                while (--index >= 0 && isNaN(this.yearlyData[years[index]][key]));
                return index;
            }

            getValue(year, key) {
                if (!isNaN(this.yearlyData[year][key])) {
                    return this.yearlyData[year][key];
                }
                var years = Object.keys(this.yearlyData);
                var index = years.indexOf(year.toString());
                var lowerBound = this.upperBound(years, index, key);
                var upperBound = this.lowerBound(years, index, key);
                if (lowerBound == -1) {
                    return this.yearlyData[years[upperBound]][key];
                }
                if (upperBound == -1) {
                    return this.yearlyData[years[lowerBound]][key];
                }
                var lowerYear = years[lowerBound];
                var upperYear = years[upperBound];
                var lowerValue, upperValue;
                try {
                    lowerValue = this.yearlyData[lowerYear][key];
                    upperValue = this.yearlyData[upperYear][key];
                } catch (e) {
                    console.log(years);
                    console.log(lowerBound, lowerYear, lowerValue);
                    console.log(upperBound, upperYear, upperValue);
                    throw e;
                }
                return (year - lowerYear) / (upperYear - lowerYear) * (upperValue - lowerValue) + lowerValue;
            }

            getMax(key) {
                var max = -1;
                for (var year in this.yearlyData) {
                    if (this.yearlyData[year][key] > max) {
                        max = this.yearlyData[year][key];
                    }
                }
                return max;
            }

            getMin(key) {
                var min = -1;
                for (var year in this.yearlyData) {
                    if (!isNaN(this.yearlyData[year][key]) && (this.yearlyData[year][key] < min || min == -1)) {
                        min = this.yearlyData[year][key];
                    }
                }
                return min;
            }

            hasYear(year) {
                return year in this.yearlyData;
            }
        }

        function getMin(countries, key) {
            return Math.min(...countries.map(country => country.getMin(key)));
        }

        function getMax(countries, key) {
            return Math.max(...countries.map(country => country.getMax(key)));
        }

        function groupBy(array, key) {
            return array.reduce(function (rv, x) {
                (rv[x[key]] = rv[x[key]] || []).push(x);
                return rv;
            }, {});
        };

        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }

        var minComp, maxComp, minGdp, maxGdp, minYear, maxYear, year, yearScale, controlHandle, playButton;
        var countries;
        var colorMap = {};

        d3.csv('./GCI_CompleteData2.csv', data => {
            var grouped = groupBy(data, keys.country);
            countries = []
            for (var name in grouped) {
                countries.push(new Country(grouped[name]));
            }

            minGdp = getMin(countries, keys.gdp);
            maxGdp = getMax(countries, keys.gdp);
            minGdp = 100;
            maxGdp = 4000000;
            minComp = getMin(countries, keys.competitiveness);
            maxComp = getMax(countries, keys.competitiveness);
            minComp = 2.5;
            maxComp = 6;
            minYear = getMin(countries, keys.year);
            maxYear = getMax(countries, keys.year);
            minYear = 2007;
            maxYear = 2017;

            // var data = Object.values(countries[0].yearlyData).map(d => [d.year - minYear, d.global_competitiveness]);
            // console.log(data);

            // Setting up the axis
            xScale.domain([minGdp, maxGdp]);
            yScale.domain([minComp, maxComp]);

            // Create the x-axis
            plot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "x-axis")
                .attr("transform", "translate(0," + plot.height + ")")
                .call(xAxis);

            // Create the y axis
            plot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "y-axis")
                .call(yAxis);


            plot.canvas.append("text")
                .attr("transform",
                    "translate(" + (plot.width / 2) + " ," +
                    (plot.height + plot.margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text("GDP");

            plot.canvas.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - plot.margin.left)
                .attr("x", 0 - (plot.height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Gloabl competitiveness");


            // Create the pilalr x axis
            pxScale.domain([0, Math.ceil(highestPillar)]);
            pxAxis.ticks(Math.ceil(highestPillar));

            pillarPlot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "pillar-x-axis")
                .attr("transform", "translate(0," + pillarPlot.height + ")")
                .call(pxAxis);

            // Create the pillar y axis
            pillarPlot.canvas.append("g")
                .attr("class", "axis")
                .attr("id", "pillar-y-axis")
                .call(pyAxis);

            pillarPlot.canvas.append("text")
                .attr("transform",
                    "translate(" + (pillarPlot.width / 2) + " ," +
                    (pillarPlot.height + pillarPlot.margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text("Value");

            // Setting up the colors
            var regions = countries.map(c => c.classification).filter(onlyUnique);
            for (var i = 0; i < regions.length; i++) {
                colorMap[regions[i]] = ColorPalett[i];
            }


            // Build legend to the left
            var enteredLegend = legend.selectAll("g")
                .data(regions)
                .enter();

            enteredLegend.append("circle")
                .attr("cy", (region, i) => i * 25 + 10)
                .attr("r", 7.5)
                .attr("fill", region => colorMap[region])
                .classed("legend-circle", true);

            enteredLegend.append("text")
                .classed("legend", true)
                .text(region => region)
                .attr("y", (region, i) => i * 25 + 10);


            //Setup control
            yearScale = d3.scaleLinear()
                .domain([minYear, maxYear])
                .range([0, control.width - control.lineOffset]);

            var slider = control.canvas.append("g")
                .attr("transform", "translate(" + 50 + ", 0)")
                .classed("slider", true);

            slider.append("line")
                .attr("x1", yearScale.range()[0])
                .attr("x1", yearScale.range()[1])
                .call(d3.drag()
                    .on("start drag", () => {
                        var x = d3.event.x + yearScale.range()[1] / (maxYear - minYear) / 2;
                        var newYear = parseInt(yearScale.invert(x));
                        playPause(false);
                        if (newYear != year)
                            generateVis(newYear, selection);
                    }));

            controlHandle = slider.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", 15);

            slider.append("g")
                .attr("transform", "translate(0," + 36 + ")")
                .selectAll("text")
                .data(yearScale.ticks(maxYear - minYear))
                .enter()
                .append("text")
                .attr("x", yearScale)
                .text(d => d);

            playButton = control.canvas.append("g")
                .classed("play-btn", true);

            playButton.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", 18);
            playButton.append("text")
                .text("▶")
                .on('click', () => {
                    playPause();
                });

            generateVis(minYear, []);
        });

        function scaleX(gdp) {
            return plot.width * Math.log(gdp / minGdp) / Math.log(maxGdp / minGdp);
        }

        function scaleY(comp) {
            return plot.height - plot.height * (comp - minComp) / (maxComp - minComp);
        }

        function scaleR(population) {
            return Math.sqrt(population) / (750000 / plot.width);
        }

        function strokeColor(country) {
            return isSelected(country) ?
                SelectionColors[selection.length - 1 - selection.indexOf(country)] :
                "black";
        }

        function startHover(country) {
            country.circle.classed("hovered", true);
            country.label.classed("hovered", true);
            plotPoints.selectAll("circle").classed("blend-out", true);
            country.circle.classed("blend-out", false);
        }

        function stopHover(country) {
            plotPoints.selectAll("circle")
                .classed("hovered", false)
                .classed("blend-out", false);
            plotLabels.selectAll("text")
                .classed("hovered", false);
        }

        var selected = undefined;
        var selection = [];

        function isIn(array, value) {
            return array.indexOf(value) > -1;
        }

        function isSelected(country) {
            return isIn(selection, country);
        }

        function removeSelection(country) {
            if (isSelected(country)) {
                selection.splice(selection.indexOf(country), 1);
                generateVis(year, selection);
            }
        }

        function addSeelction(country) {
            if (!isSelected(country)) {
                if (selection.length >= SelectionColors.length) {
                    selection.shift();
                }
                selection.push(country);
                generateVis(year, selection);
            }
        }

        function onClickCountry(country) {
            if (isSelected(country)) {
                removeSelection(country);
            } else {
                addSeelction(country);
            }
        }

        function generateVis(newYear, newSelection) {
            if (newYear < minYear || newYear > maxYear)
                return;
            selection = newSelection;
            year = newYear;
            controlHandle.transition()
                .attr("cx", yearScale(year));

            drawMainVis();
            drawPillars();
            drawHistory();
        }

        function drawMainVis() {
            var currentCountries = countries.filter(country =>
                    country.hasYear(year))
                .sort((c1, c2) =>
                    c2.getValue(year, keys.population) - c1.getValue(year, keys.population));


            var points = plotPoints.selectAll("circle")
                .data(currentCountries, country => country.name);

            // Add Point
            points.enter()
                .append("circle")
                .attr("id", country => country.circleId)
                .classed("country-circle", true)
                .on("mouseover", startHover)
                .on("mouseout", stopHover)
                .on("click", onClickCountry)
                .attr("transform", country => country.transform(year))
                .style("fill", country => colorMap[country.classification])
                .merge(points) // Set attributes for all bubbles
                .classed('selected', isSelected)
                .transition()
                .duration(200)
                .attr("r", country => scaleR(country.getValue(year, keys.population)))
                .attr("transform", country => country.transform(year))
                .attr("stroke", strokeColor);

            // Add Text
            var labels = plotLabels.selectAll("text")
                .data(currentCountries, country => country.name);

            labels.enter()
                .append("text")
                .attr("id", country => country.labelId)
                .text(country => country.name)
                .classed("country-label", true)
                .merge(labels) // Set attributes for all labels
                .classed('selected', isSelected)
                .transition()
                .duration(200)
                .attr("transform", country => country.transform(year));

            points.exit()
                .transition()
                .duration(200)
                .attr("r", 0)
                .remove();
            labels.exit()
                .remove();
        }

        function drawPillars() {
            // Pillars
            var reverseSel = selection.slice().reverse();
            // Selecting the data to visualize
            var pillarData = reverseSel.filter(c => c.hasYear(year)).map((c, ind) =>
                keys.pillars.map((name, i) => {
                    return {
                        value: c.yearlyData[year][name],
                        pillar: name,
                        index: i,
                        country_index: ind,
                        country: c
                    }
                }));
            // Flatten
            pillarData = [].concat.apply([], pillarData);

            var nSelection = selection.length;

            var pillars = pillarBars.selectAll("rect")
                .data(pillarData, p => p.pillar + p.country.name);

            var pillarHeight = pillarPlot.height / 15 / nSelection;

            pillars.enter()
                .append("rect")
                .classed("pillar", true)
                .attr("x", 0)
                .attr("y", (p, i) => p.index * pillarPlot.height / 12 + pillarHeight * p.country_index + pillarHeight *
                    nSelection / 8)
                .attr("stroke", "black")
                .merge(pillars) // Set attributes for all pillars
                .attr("fill", d => strokeColor(d.country))
                .transition()
                .delay((p, i) => i * 10)
                .duration(150)
                .attr("height", pillarHeight)
                .attr("x", 0.5) // moving it 0.5 to the right to compensate for the border
                .attr("y", (p, i) => p.index * pillarPlot.height / 12 + pillarHeight * p.country_index + pillarHeight *
                    nSelection / 8)
                .attr("width", p => p.value * pillarPlot.width / highestPillar - 1); // -1 to compensate the stroke border

            pillars.exit()
                .transition()
                .delay((p, i) => i * 10)
                .duration(150)
                .attr("width", 0)
                .remove();

            // Draw legend
            var legendCircles = pillarLegend.selectAll("rect")
                .data(reverseSel, (c, i) => i);
            var legendLabels = pillarLegend.selectAll("text")
                .data(reverseSel, (c, i) => c.name);

            legendCircles.enter()
                .append("rect")
                .attr("width", 20)
                .attr("height", 20)
                .classed("legend-rect", true)
                .merge(legendCircles)
                .attr("fill", strokeColor)
                .attr("x", (c, i) => i * (pillarPlot.outer_width - 2 * pillarPlot.legend_margin.left) / 2 + 10);

            legendCircles.exit()
                .transition()
                .duration(200)
                .attr("width", 0)
                .attr("height", 0)
                .style("transform", "translate(10px, 10px)")
                .remove();

            legendLabels.enter()
                .append("text")
                .classed("legend", true)
                .text(c => c.name)
                .attr("x", -200)
                .merge(legendLabels)
                .transition()
                .duration(300)
                .attr("x", (p, i) => i * (pillarPlot.outer_width - 2 * pillarPlot.legend_margin.left) / 2 + 20);

            legendLabels.exit()
                .remove();
        }

        function drawHistory() {
            var selected = selection[selection.length - 1];
            var hisData = []
            if (selected != null) {
                hisData = Object.values(selected.yearlyData).filter(data => selected.hasYear(data.year));
            }
            var hisPoints = historyPoints.selectAll("circle")
                .data(hisData, data => data.name + data.year);
            var hisLabels = historyLabels.selectAll("text")
                .data(hisData, data => data.name + data.year);

            hisPoints.enter()
                .append("circle")
                .attr("id", data => selected.circleId + data.year)
                .attr("transform", data => selected.transform(data.year))
                .classed("country-circle", true)
                .classed("country-history", true)
                .on("mouseover", data => selected.overHistory(data))
                .on("mouseout", data => selected.outHistory(data))
                .on("click", () => selected.selected = false)
                .transition()
                .delay((d, i) => i * 50)
                .duration(200)
                .attr("r", data => scaleR(data.population))
                .style("opacity", data => (data.year - minYear) / (maxYear - minYear) / 2 + 0.3)
                .style("fill", data => colorMap[selected.classification]);

            hisLabels.enter()
                .append("text")
                .attr("id", data => selected.labelId + data.year)
                .text(data => selected.name + " " + data.year)
                .attr("transform", data => selected.transform(data.year))
                .classed("country-label", true)
                .classed("country-history", true);

            hisPoints.exit()
                .interrupt()
                .transition()
                .duration(200)
                .attr("r", 0)
                .remove();
            hisLabels.exit().remove();
        }

        var timer = -1;

        function playPause(play = undefined) {
            if ((timer == -1 && play === undefined) || play === true) {
                var nextYear = year < maxYear ? year + 1 : minYear;
                timer = setInterval(() => {
                    generateVis(nextYear, selection);
                    nextYear += 1;
                    if (nextYear > maxYear) {
                        playPause();
                    }
                }, 1000);
                playButton.select("text").text("❚❚");
            } else {
                clearInterval(timer);
                timer = -1;
                playButton.select("text").text("▶");
            }
        }
    </script>
</body>

</html>